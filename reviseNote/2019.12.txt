控制台输出带颜色字体：console.log('aa%caa', 'color:red')，%c表示颜色。实测一条语句仅第一个%c有效


1.BOM
1.1window对象
①全局作用域
直接定义的变量归属于window对象，但是在IE9以下的版本[[Configurable]]是false，所以通过delete删除不了。如
var color = 'red'
delete window.color会异常
而window.color = 'red'定义的则可以删除

并且，访问未声明的变量会报错，但是通过查询window对象来访问则不会。如
var newVal = oldVal,oldVal未定义所以会报错，而
var newVal = window.newVal则不会

②框架frame
window.frames[下标/name]。
而最好使用top.frames[下标/name]，top指向最外层框架的window。frame在H5已不支持

parent，self

③窗口位置
screenLeft和screenTop。在Opera浏览器中，与其他浏览器有所不同，需要使用screenX和Y。
var leftPos = (typeof window.screenLeft == 'number') ? window.screenLeft : window.screenX

移动，moveTo(x,y)，moveBy(距离x，距离y)。默认禁用

④窗口大小
innerWidth，innerHeight，outerWidth，outerHeight。不同浏览器有所不同

resizeTo(),resizeBy()

⑤导航和打开窗口
window.open(url,target,特性字符串,新页面是否取代历史记录中的当前页面)
如，<a href="xxx" target="aaa">则，会找到一个name叫aaa的窗口或框架来打开页面，如果没有则新建并命名为aaa，此外，第二个参数还可以是一些特殊的，如_self,_parent,_top,_blank.
第三个参数是对窗口进行尺寸等设置的字符串，逗号分隔，如"height=400,width=500,top=10,left=10,resize=true"

close(),closed

opener
将其置为null则表示该页面在单独的进程中运行，不需要通信，也无法再恢复
安全限制，弹窗屏蔽程序。
如果被屏蔽，则window.open()就会返回null
var flag = false
try {
	var newWin = window.open(...)
	if(newWin == null) {
		flag = true
	}
} catch (ex) {
	flag = true
}
if (flag) {
	alert('Popup was blocked')
}

⑥间歇调用，超时调用
setInterval，setTimeout，clearInterval，clearTimeout()

⑦系统对话框
alert(),confirm(),prompt()
这几个方法是同步和模态的，也就是打开的时候代码会停止执行，关闭后继续执行。
if (confirm('OK?')) {
	alert('OK')//点击确定
} else {
	alert('NO')//点击取消或X
}
prompt会在确定取消按钮之外显示一个文本框，参数是提示值和输入框里的默认值
点击确定后，会返回输入框里的值，取消或关闭，会返回null

window.print()打印对话框，window.find()查找对话框

1.2location对象
window.location和document.location指向同一个对象
属性：
hash（#后的字符），host（域名+端口号（若有）），hostName(域名），href（URL，toString(）方法也返回该URL)，pathname(URL中的目录和/或文件名)，port，protocol（协议，http:或https:），search（查询字符串，问号开头。可封装获取参数的方法）
location.assign(URL)??
以上属性直接修改之后都会在浏览器的历史记录中生成一条记录，即可用返回修改前的url的页面。如果想要不能返回，可用使用location.replace(URL)
此外，location.reload()，参数可以是true（从服务器重新加载），如果不带参数，则可能从缓存加载

1.3navigator对象
属性：appCodeName（一般是Mozilla），appMinorVersion（次版本信息），appName（完整名称），appVersion，buildID（编译版本），cookieEnabled，cpuClass，javaEnabled()，language，mimeTypes，onLine（是否连接到因特网），opsProfile，oscpu，platform（系统平台），plugins，preference()（用户首选项设置），product（产品名称），productSub（产品次要信息），registerContentHandler()（针对特定MIME类型将一根站点注册为处理程序），registerProtocolHandler()（针对特定协议将一根站点注册为处理程序），securityPolicy（已废弃），systemLanguage，taintEnabled()（已废弃），userAgent（浏览器的用户代理字符串），userLanguage（操作系统的默认语言），userProfile（借以访问用户个人信息的对象），vendor（品牌），venderSub。

①检测插件（plugins）
一般浏览器遍历plugins数组即可完成检测，而一些低版本IE不支持Netscape式的插件而是以COM对象的方式实现插件的，因而要使用专有的ActiveXObject类型来尝试创建特定插件示例，且必须要知道其COM标识符。
function hasIEPlugin(name) {
	try{
		new ActiveXObject(name)
		return true
	} catch(ex) {
		return false
	}
}
plugins集合有一个refresh()方法，参数是是否刷新页面的布尔值

②注册处理程序
Firefox2为navigator新增了registerContentHandler(MIME类型，url，程序名称)和registerProtocolHandler(协议（如mailto，ftp），url，程序名)，可以让一个站点指明它可以处理特定类型的信息。
如：
将一个站点注册为处理RSS源的处理程序(%s表示RSS源URL)：
navigator.registerContentHandler('application/rss+xml','http://xxx?feed=%s','some reader')
将一个应用程序注册为默认邮件客户端(%s表示原始请求)：
navigator.registerProtocolHandler('mailto','http://www.xxx','some mail cliend')

1.4screen对象
属性：height，width，availWidth，availHeight等，有一定的浏览器支持的兼容性。
使用，如：window.resizeTo(screen.availWidth, screen.availHeight)。许多浏览器会禁用调整浏览器窗口大小的能力，因为需要注意一下兼容性。

1.5history对象
go()方法，负数表示后退步数，正数表示前进。也可以传一个字符串，此时会调整到前后历史记录中包含该字符串的第一个位置（最近的位置），如果没有，则不处理。
back(),forward()方法，后退前进。
history的length属性，可用于确定是否是打开窗口的第一个页面（length==0）。结合前边，修改url的一些内容如hash，会生成新的历史记录。

2 客户端检测
2.1能力检测
if(object.propertyInQuestion) {
},例：
function getElement(id){
	if (document.getElementById) {
		return document.getElementById(id)
	} else if (document.all) {
		return document.all[id]
	} else {
		throw new Error('xxx')
	}
}

此外，!!,typeof也常有于能力检测，且多结合使用。
function isHostMethod(object, property) {
	var t = typeof object[property]
	return t == 'function' || (!!(t == 'object' && object[property])) || t == 'unknown'//IE中xhr.open返回unknown
}
浏览器检测？

2.2怪癖检测
如IE8[[DontEnum]]的属性？

2.3用户代理检测
利用代理检测客户端精确信息和版本


3 DOM
3.1节点层次
3.1.1①Node类型
每个节点都有一个nodeType属性，其值是12个数值常量之一，如Node.ELEMENT_NODE//1
兼容性：IE没有公开Node类型的构造函数，因而不能直接使用常量来对比判断，而应该直接使用常量对应的数值

除了nodeType外，节点还有nodeName和nodeValue两个常用属性，还有childNodes属性，childNodes是一个类似数组的结构，但不是Array实例，且是基于DOM结构动态执行查询的结果，因而是可以动态刷新的。有length属性，且可以使用xxx.childNodes[index]或xxx.childNodes.item(index)来访问。

在IE8以后的版本（9+），可以将NodeList转换为数组，IE8及以前版本是将NodeList实现为COM对象。
function convertToArray(nodes) {
	var array = null
	try{
		array = Array.prototype.slice.call(nodes, 0)//非IE
	} catch(ex) {
		array = new Array()
		for (var i=0,len = nodes.length;i<len;i++) {
			array.push(nodes[i])
		}
	}
	return array
}

②节点关系（父子兄弟）
此外，每个节点也都有parentNode属性，而兄弟节点之间可以通过nextSibling和previousSibling访问，第一个节点的pre...为null，最后一个节点的next...为null。父节点的firstChild和lastChild分别执行子节点的第一个和最后一个节点。检测有无子节点，除了判断childNodes是否为空为null、判断长度外，可以之间使用hasChildNodes()方法。还有ownerDocument属性，执行表示整个文档的节点（当前dom的最外层）

③节点操作
appendChild()，向目标节点的childNodes的末尾插入节点，返回新增的节点。一个节点不能同时出现在两个地方，因而如果参数节点是已经存在的，则会从原位置移动到目标位置。一个小技巧，有多个子节点时，可以通过appendChild将目标子节点调整成lastChild。

insertBefore()，如果不放在末尾，可以使用该方法。与前边的方法类似，返回新节点，但是参数有要插入的节点和参照节点两个，执行后插入的节点成为参照节点的前一个兄弟节点（previousSibling）。如果第二个参数为null，则等效于appendChild()

replaceChild()参数是要插入替换的节点和被替换移除掉的节点，返回被移除的节点。

removeChild()参数是要移除的节点，返回该节点。

并不是全部类型的节点都有子节点。

④其他
cloneNode()，参数是一个布尔值，表示是否深复制（深复制会复制其整改子节点数，浅复制只复制本身节点（子节点为null））。不会复制事件，但IE有会复制事件的bug，最好在复制之前移除事件。

normalize(),处理文本节点，将空的文本节点移除，将相邻的文本节点合并。
以上两个方法所有类型的节点都支持。

3.1.2Document类型
①文档子节点
JS通过document类型表示文档，js里document对象是HTMLDocument的一个实例，继承自Document类型，表示整个HTML页面，且是window对象的一个属性。
节点类型nodeType是9，像一个普通节点一样拥有nodeName等其他属性。
其子节点可以是DocumentType、Element、ProcessingInstructior、Comment。但还可以通过childNodes来访问文档元素，或通过documentElement属性访问（一般使用这个，指向<html>元素）。可以直接用过body属性来访问body标签，同理还有head等。
document.doctype//对<!DOCTYPE>的引用。不同浏览器对该属性的支持差别很大。类似的对注释的处理也差异很大。

②文档信息
一些特殊属性：title（指向<title>节点），URL，domain（域名），referrer（链接到当前页面的那个页面的URL）。其中domain和title是可以设置的。但安全限制不允许修改domain，因而只能设置为url中包含的域名（可以子域名二级域名），可以通过这样修改来解决跨域问题，但修改是不可逆的。如：
document.domain = b.com//原url：a.b.com。但设置了之后想再设置回去，则会抛出异常。即可以由紧致设置为松散，但不能由松散设置为紧致（始于IE8）。

③查找元素
getElement(s)Byxxxxxx（id，name，tagName等），如果是HTMLCollection对象的结果（类似数组），则有namedItem()方法，参数是name，且可以直接通过name来访问，如var el = document.getElementsByTagName('img')['myImg']//等效于xxxx(前边的内容)('img').namedItem('myImg')。
如果tagname参数是"*"，则返回页面中的所有元素。

④特殊元素
document.anchors（所有带name属性的<a>）
	.applets（所有applet元素）
	.forms....
	.images...
	.links（所有带href特性的<a>）

⑤DOM一致性检测
document.implementation
有hasFeature()方法，参数是功能名称和版本号，可配合前边的兼容性检测一起使用

⑥文档写入
write(),writeln()（会换行）,open(),close()
如document.write('<script>xxxxx' + '<\/script>')// 注意\/
如果在页面加载过程中write，会直接向页面输入，如果在页面加载完后write，则会重写整个页面。（严格模式不支持文档写入）open和close用于打开和关闭页面的输出流。

3.1.3Element 类型
nodeType为1，nodeName为元素标签名（不同浏览器的大小写可能不同）。
①HTML元素
特性：id，title，lang（语言），dir（方向，值为ltr（left-to-right）或rtl）,className

②取得特性
getAttribute()（一般直接获取特性，获取自定义特性时才用）,setAttribute(),removeAttribute()。
自定义特性，即不在标准特性中的特性，H5规范要求自定义特性前边加上data-，特性名称不区分大小写。以上方法对自定义特性也有效。

③attributes属性
与NodeList类型，attributes属性中包含一个NamedNodeMap。包含的方法：
getNamedItem(name),removeNamedItem(name),setNamedItem(node(添加节点)),item(pos下标)。
每个特性节点有specified属性，表示是否是指定的或已通过setAttribute添加的。

④创建元素
使用document.createElement(标签名HTML中不区分大小写)，参数也可以是完整的元素的字符串，但是这样会有一些局限性。

3.1.4Text类型（nodeType 3,nodeName '#text',nodeValue或data都是节点包含的文本,不支持子节点，有length）
appendData()将文本内容添加到节点末尾，
deleteData(起点下标，要删除的长度)，
insertData（位置下标，要插入的内容），
replaceData（起点位置下标，要替换的长度，被替换成的文本）
splitText(要分割的下标位置)
substringData(起点下标，长度)

修改节点内容时，到呈现到页面上会被根据文档类型编码

<div></div>//没有文本节点
<div> </div>//直接是一个空格就相当于是一个文本节点

创建文本节点：createTextNode()
规范化文本节点：normalize()（在父节点上执行）
分割。。。：splitText()

3.1.5 Comment类型（nodeType 8,nodeName '#comment'，nodeValue或data是注释内容，没有子节点）
与Text类型继承自相同的基类，拥有和Text类型除splitText()方法外的全部方法
createComment()

3.1.6 CDATASection类型（基于XML，与comment类似）

3.1.7 DocumentType类型（支持性有限）

3.1.8 DocumentFragement类型（文档片段，一般用于循环插入页面时作为中转避免多次渲染，有create方法）

3.1.9 Attr类型（name-名称，value-值，specified-默认或指定的）
var attr = document.createAttribute('align')
attr.value = 'left'
element.setAttributeNode(attr)
alert(element.attributes['align'].value)//left
alert(element.getAttributeNode('align').value)//left
alert(element.getAttribute('align'))//left

3.2 DOM操作
3.2.1动态脚本，动态样式
在需要时加载js，即在js里向页面appendChild指定js或js片段。不会立即下载？？（不会影响前边的？但是加载后后边可以直接使用）
function loadScript(url) {
	var script = document.createElement('script')
	script.type = 'text/javascript'
	script.src = url
	document.body.appendChild(script)
}
// 判断是否加载完成？

function loadScriptString(code) {
	var script = document.createElement('script')
	script.type = 'text/javascript'
	try {
		script.appendChild(document.createTextNode(code))
	} catch (ex) {
		script.text = code//兼容IE
	}
	document.body.appendChild(script)
}

function loadStyles(url) {
	var link = document.createElement('link')
	link.rel = 'stylesheet'
	link.type = 'text/css'
	link.href = url
	document.getElementsByTagName('head')[0].appendChild(link)
}
// css是异步加载的，不需要关系什么时候加载完成的问题
function loadStyleString(css) {
	var style = document.createElement('style')
	style.type = 'text/css'
	try {
		style.appendChild(document.createTextNode(css))
	} catch (ex) {
		style.styleSheet.cssText = css// 兼容IE。另外，ie中重复设置一个style的属性或设置为空时容易崩溃
	}
	document.getElementsByTagName('head')[0].appendChild(style)
}

3.2.2 表格
<table>属性和方法：
caption：对<caption>元素的指针
tBodies：<tbody>元素的HTMLCollection
tFoot：对<tfoot>元素的指针
tHead：同上
rows：所有行的HTMLCollection
createTHead()/createTFoot()/createCaption()/insertRow(下标)
deleteTHead()/deleteTFoot()/deleteCaption()/deleteRow(下标)
<tr>元素属性方法：
cells：<tr>元素中单元格的HTMLCollection
deleteCell(index)/insertCell(index)

3.2.3 使用NodeList
NodeList，NamedNodeMap，HTMLCollection：
都是动态的。应尽量减少访问次数，因为每次访问NodeList，都会运行一次基于文档的查询，所以可以将从NodeList中取的的值缓存起来使用来避免多次查询。

4 DOM扩展
4.1 选择符API
如jQuery中的选择器等。Selectors API（W#C发起制定的一个标准） Level 1的核心方法：
querySelector()和querySelectorAll()（与前者差异：返回的是一个NodeList实例而不是具体的元素）
同样，访问这个NodeList集中的某一项的时候可以使用.item(i)或[i]

matchedSelector(),避免兼容性问题（ie里是msMatchedSelector(),谷歌是webkitMat...,火狐是mozM...）
使用：if (document.body.matchesSelector('body .page1'))
// 兼容性封装
function matchesSelector(ele, selector) {
	if (ele.matchesSelector) {
		return ele.matchesSelector(selector)
	} else if (ele.msMatchesSelector) {
		return ele.msMatchesSelector(selector)
	} else if (ele.mozMatchesSelector) {
		return ele.mozMatchesSelector(selector)
	} else if (ele.webkitMatchesSelector) {
		return ele.webkitMatchesSelector(selector)
	} else {
		throw new Error('xxx')
	}
}
使用：if(matchesSelector(document.body, 'body .page1'))

4.2 元素遍历
为避免不同版本对空格是否返回文本节点的兼容性问题，w3c定义了一组新的属性：
childElementCount：不包括文本和注释的子元素个数
firstElementChild：指向第一个元素，firstChild的元素版
lastElementChild：.../previousElementSibling:.../nextElementSibling:...

4.3 H5（这里只介绍DOM方面的扩展）
① 与类相关的扩充：
getElementsByClassName()（document或节点上都可以使用）；
classList属性（DOMTokenList的实例）：与前边的集合类型类似，可以使用item(i)或[i]访问内部元素，且有add(),contains(),remove(),toggle()方法，用以对class样式进行直接增删改和判断等，解决了改className时需要拆分合并的效率问题。

②焦点管理
document.activeElement，引用DOM中当前获得了焦点的元素（获得焦点的方式：页面加载，用户输入，focus()方法）
document.hasFocus()方法判断是否获得了焦点，以确认是否在与页面交互（如切换到别的页面时当前页面的视频播放停止）

③HTMLDocument的变化
readyState属性（loading、complete），兼容模式compatMode（CSS1Compat（标准模式），BackCompat（混杂模式）），head属性

④字符集属性
charset，默认是UTF-16，可以通过meta、响应头部或直接设置来修改
defaultCharset，默认字符集设置

⑤自定义数据属性
data-属性名
添加了自定义属性后，可以通过元素的dataset属性（DOMStringMap实例）来访问自定义属性的值

⑥插入标记
innerHTML属性，可以读取或修改内部内容。有一些元素不支持该属性
但在写入script的时候有一定的兼容性。script是无作用域的元素，可以通过添加时一起添加有作用域的空元素或设置defer属性来解决。如：
div.innerHTML = '_<style xxx>xxx</style>'
div.removeChild(div.firstChild)

outerHTML属性
与前者的差异在于outer是包括元素本身的节点数，而inner是元素的子节点

insertAdjacentHTML()方法
参数：插入位置和HTML文本
位置：‘beforebegin’作为前一个兄弟节点插入
‘afterbegin’作为第一个子元素插入
‘beforeend’作为最后一个子元素插入
‘afterend’作为后一个兄弟节点插入

内存和性能：
删除带事件处理的节点时，不会一并删除绑定的事件和js对象属性；
但是由于设置innerHTML和outerHTML属性时会创建浏览器级别的HTML解析器，效率会比js快很多；
但是要避免过多创建解析器，比如for循环中尽量不要新建。

⑦scrollIntoView()方法
参数如果是true或不传，则滚动后顶部对齐；如果传false，则尽可能出现在视口，如果可以呈现完，则底部对齐。


4.4专有扩展
①文档模式（meta）
②children属性
③contains()方法
DOM Level3的compareDocumentPosition()也能确认节点关系，返回结果根据节点关系有不同的结果
④插入文本
innerText，outerText。firefox不支持innerText，但支持textContent
⑤滚动
scrollIntoViewIfNeeded(alignCenter)，若在视口中则不处理，参数表示是否垂直居中；
scrollByLines(lineCount)将元素内容滚动指定行高
scrollByPages(pageCount)滚动指定的页面高度
后两者是元素自身，前两者是容器。


5 DOM2和DOM3
document.implementation
5.1 DOM变化

5.2 样式
5.2.1 访问元素的样式
css中样式属性是下划线，js里是style属性的对应驼峰属性

①DOM样式属性和方法
style对象的一些属性和方法：
cssText，length，parentRule（CSSRule对象）,getPropertyCSSValue(propertyName)，getPropertyPriority(propertyName)（如果设置了!important则返回important否则返回空）,getPropertyValue(propertyName)，item(index)（等同于[index]）,removeProperty(propertyName),setProperty(propertyName, value, priority)

getPropertyCSSValue()返回的是一个对象

② 计算的样式
DOM2级样式增强了document.defaultView，提供了getComputedStyle()方法，参数是元素和伪元素如‘:after’，第二个可以是null；而这个方法在IE中不支持，ie可以使用currentStyle属性代替。

5.2.2 操作样式表
CSSStyleSheet，继承自StyleSheet。继承的属性：
disabled，href，media（支持的媒体类型的集合），ownerNode（ie不支持），parentStyleSheet，title，type，（除了disabled，其他都是只读），cssRules（ie为rules），ownerRule，deleteRule(index)（ie是removeRule()）,insertRule(rule,index)（ie是addRule()）

document.styleSheets，item(index)或[index]来访问；
DOM的则是sheet属性，在ie中是styleSheet属性。如：
var link = document.getElementsByTagName('link')[0]
var sheet = link.sheet || link.styleSheet

①CSS规则
CSSRule对象表示样式表中的每一条规则，是一个供其他多种类型继承的基类，最常见的就是CSSStyleRule类型（其他有@import,@font-face等），CSSStyleRule属性如下：
cssText，parentRule，parentStyleSheet，type，selectorText，style（除了最后两个，剩下的IE都不支持）

关系示例：
var sheet = document.styleSheets[0]
var rules = sheet.cssRules || sheet.rules
var rule = rules[0]
alert(rule.selectorText)//如div.box
console.log(rule.style)// 如width，height

②创建规则
insertRule(样式文本，插入位置下标)，ie中是addRule，不过参数不同，将样式文本分成了前两个参数
如：
sheet.insertRule('body{height:100px}',0)
sheet.addRule('body','height:100px',0)//ie

function insertRule(sheet, selectorText, cssText, position) {
	if(sheet.insertRule){
		sheet.insertRule(selectorText+'{'+cssText+'}',position)
	} else if (sheet.addRule) {
		sheet.addRule(selectorText, cssText, position)
	}
}

③删除样式
deleteRule(),ie是removeRule()

5.2.3元素大小
①偏移量
offsetHeight，offsetWidth，offsetLeft，offsetTop。offsetParent是父元素的偏移量，通过循环累积，可以取得元素相对浏览器的偏移量。只读

②客户区大小
clientWidth，clientHeight。内容加上边距。不同模式（混杂模式等）的body的客户区大小获取方法有所不同。只读

③滚动大小
scrollHeight/Width/Left/Top，document的在document.documentElement上。与客户区的关系不同浏览器有所不同。文档的总高度是滚动大小和客户区大小的最大值。

④确定元素大小。
getBoundingClientRect(),返回的是一个矩形对象，包含left，top，right，bottom。IE8及更早的版本是以（2,2）为原点的。可封装为兼容的方法。

5.3遍历
两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator，TreeWalker，基于给定起点对DOM进行深度优先的遍历。IE不支持DOM遍历。
NodeInterator，使用document.createNodeInterator()创建实例，参数：
root，作为起点的节点
whatToShow，表示要访问哪些节点的数字代码（可选值以常量的形式在NodeFilter类型中定义，可使用按位或'|'来组合多个选项）
filter，一个NodeFilter对象，或一个表示应该接受还是拒绝某种特定节点的函数
entityReferenceExpansion，表示是否要扩展实体引用的布尔值，在HTML页面中没有用，因为其中的实体不能扩展。
var filter = {
	// 必须要有一个acceptNode,或者filter也可以直接是这一个方法
	acceptNode: function(node){
		return node.tagName.toLowerCase() == 'p'?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP
	}
}
遍历得到的结果又nextNode()和previousNode()两个方法。

TreeWalker
是NodeInterator的一个更高级版本，除包含nextNode和previousNode两个外还有更多的方法：
parentNode(),firstChild(),lastChild(),nextSibling(),previousSibling()，currentNode属性（读写，修改可实现修改起点）
创建方法是document.createTreeWalker(),参数与前者相同。
在filter上稍有不同，区别在于不满足时的处理，且有FILTER_REJECT常量。

5.4 范围
5.4.1 DOM中的范围
document.createRange()方法
属性方法：
startContainer：包含范围起点的节点（选区中第一个节点的父节点）
startOffset：startContainer中起点的偏移量
endContainer：。。。（选区中最后一个节点的父节点）
endOffset：。。。
commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树中位置最深的那个

①用DOM范围来实现简单选择
选择文档中的一部分最简单是selectNode()或selectNodeContents(),参数是一个DOM节点。两者区别是后者只选取子节点，前者选取包括节点本身
如：
var range = document.createRange()
range.selectNode(document.getElementById('xxx'))
精细选取：
setStart/EndBefore/After(refNode)4个方法

②用DOM范围实现复杂选择
使用setStart()和setEnd()，参数是一个参照节点和一个偏移量。如此其范围的属性会相应的被修改为设置的参数。

③操作DOM范围中的内容。
如，range.deleteContends(),extractContents()。两个方法都会移除选取范围里的元素，差别在于后者返回被移除的片段，可以使用该返回值来达到插入别的地方的功能（就像剪切粘贴）。
此外还有cloneContents()方法

④插入DOM范围中的内容
insertNode()，向范围选区的开始处插入一个节点

⑤折叠DOM范围
collapse(),参数true表示折叠到起点，false表示到终点

⑥比较DOM范围
compareBoundaryPoints()，比较是否公共边界（起点终点）,参数是两个，一个是起点终点（Range.START/END_TO_END/START），一个是用来比较的范围2。结果：相同返回0，在前返回-1，在后返回1

⑦复制DOM范围
cloneRange()

⑧清理DOM范围
使用完后调用detach()来清理以达到内存回收。

在IE8之前范围有所不同，功能点基本一致，主要是对应的方法属性名字不同，如果要兼容需要特殊关照处理。