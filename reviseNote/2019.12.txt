控制台输出带颜色字体：console.log('aa%caa', 'color:red')，%c表示颜色。实测一条语句仅第一个%c有效

使用Image对象实现预加载（会预下载图片资源，但不会直接显示到页面上，以便于在需要时可以直接取缓存显示）
var img = new Image()
img.src = 'xxx'

String.fromCharCode(charcode)


1.BOM
1.1window对象
①全局作用域
直接定义的变量归属于window对象，但是在IE9以下的版本[[Configurable]]是false，所以通过delete删除不了。如
var color = 'red'
delete window.color会异常
而window.color = 'red'定义的则可以删除

并且，访问未声明的变量会报错，但是通过查询window对象来访问则不会。如
var newVal = oldVal,oldVal未定义所以会报错，而
var newVal = window.newVal则不会

②框架frame
window.frames[下标/name]。
而最好使用top.frames[下标/name]，top指向最外层框架的window。frame在H5已不支持

parent，self

③窗口位置
screenLeft和screenTop。在Opera浏览器中，与其他浏览器有所不同，需要使用screenX和Y。
var leftPos = (typeof window.screenLeft == 'number') ? window.screenLeft : window.screenX

移动，moveTo(x,y)，moveBy(距离x，距离y)。默认禁用

④窗口大小
innerWidth，innerHeight，outerWidth，outerHeight。不同浏览器有所不同

resizeTo(),resizeBy()

⑤导航和打开窗口
window.open(url,target,特性字符串,新页面是否取代历史记录中的当前页面)
如，<a href="xxx" target="aaa">则，会找到一个name叫aaa的窗口或框架来打开页面，如果没有则新建并命名为aaa，此外，第二个参数还可以是一些特殊的，如_self,_parent,_top,_blank.
第三个参数是对窗口进行尺寸等设置的字符串，逗号分隔，如"height=400,width=500,top=10,left=10,resize=true"

close(),closed

opener
将其置为null则表示该页面在单独的进程中运行，不需要通信，也无法再恢复
安全限制，弹窗屏蔽程序。
如果被屏蔽，则window.open()就会返回null
var flag = false
try {
	var newWin = window.open(...)
	if(newWin == null) {
		flag = true
	}
} catch (ex) {
	flag = true
}
if (flag) {
	alert('Popup was blocked')
}

⑥间歇调用，超时调用
setInterval，setTimeout，clearInterval，clearTimeout()

⑦系统对话框
alert(),confirm(),prompt()
这几个方法是同步和模态的，也就是打开的时候代码会停止执行，关闭后继续执行。
if (confirm('OK?')) {
	alert('OK')//点击确定
} else {
	alert('NO')//点击取消或X
}
prompt会在确定取消按钮之外显示一个文本框，参数是提示值和输入框里的默认值
点击确定后，会返回输入框里的值，取消或关闭，会返回null

window.print()打印对话框，window.find()查找对话框

1.2location对象
window.location和document.location指向同一个对象
属性：
hash（#后的字符），host（域名+端口号（若有）），hostName(域名），href（URL，toString(）方法也返回该URL)，pathname(URL中的目录和/或文件名)，port，protocol（协议，http:或https:），search（查询字符串，问号开头。可封装获取参数的方法）
location.assign(URL)??
以上属性直接修改之后都会在浏览器的历史记录中生成一条记录，即可用返回修改前的url的页面。如果想要不能返回，可用使用location.replace(URL)
此外，location.reload()，参数可以是true（从服务器重新加载），如果不带参数，则可能从缓存加载

1.3navigator对象
属性：appCodeName（一般是Mozilla），appMinorVersion（次版本信息），appName（完整名称），appVersion，buildID（编译版本），cookieEnabled，cpuClass，javaEnabled()，language，mimeTypes，onLine（是否连接到因特网），opsProfile，oscpu，platform（系统平台），plugins，preference()（用户首选项设置），product（产品名称），productSub（产品次要信息），registerContentHandler()（针对特定MIME类型将一根站点注册为处理程序），registerProtocolHandler()（针对特定协议将一根站点注册为处理程序），securityPolicy（已废弃），systemLanguage，taintEnabled()（已废弃），userAgent（浏览器的用户代理字符串），userLanguage（操作系统的默认语言），userProfile（借以访问用户个人信息的对象），vendor（品牌），venderSub。

①检测插件（plugins）
一般浏览器遍历plugins数组即可完成检测，而一些低版本IE不支持Netscape式的插件而是以COM对象的方式实现插件的，因而要使用专有的ActiveXObject类型来尝试创建特定插件示例，且必须要知道其COM标识符。
function hasIEPlugin(name) {
	try{
		new ActiveXObject(name)
		return true
	} catch(ex) {
		return false
	}
}
plugins集合有一个refresh()方法，参数是是否刷新页面的布尔值

②注册处理程序
Firefox2为navigator新增了registerContentHandler(MIME类型，url，程序名称)和registerProtocolHandler(协议（如mailto，ftp），url，程序名)，可以让一个站点指明它可以处理特定类型的信息。
如：
将一个站点注册为处理RSS源的处理程序(%s表示RSS源URL)：
navigator.registerContentHandler('application/rss+xml','http://xxx?feed=%s','some reader')
将一个应用程序注册为默认邮件客户端(%s表示原始请求)：
navigator.registerProtocolHandler('mailto','http://www.xxx','some mail cliend')

1.4screen对象
属性：height，width，availWidth，availHeight等，有一定的浏览器支持的兼容性。
使用，如：window.resizeTo(screen.availWidth, screen.availHeight)。许多浏览器会禁用调整浏览器窗口大小的能力，因为需要注意一下兼容性。

1.5history对象
go()方法，负数表示后退步数，正数表示前进。也可以传一个字符串，此时会调整到前后历史记录中包含该字符串的第一个位置（最近的位置），如果没有，则不处理。
back(),forward()方法，后退前进。
history的length属性，可用于确定是否是打开窗口的第一个页面（length==0）。结合前边，修改url的一些内容如hash，会生成新的历史记录。

2 客户端检测
2.1能力检测
if(object.propertyInQuestion) {
},例：
function getElement(id){
	if (document.getElementById) {
		return document.getElementById(id)
	} else if (document.all) {
		return document.all[id]
	} else {
		throw new Error('xxx')
	}
}

此外，!!,typeof也常有于能力检测，且多结合使用。
function isHostMethod(object, property) {
	var t = typeof object[property]
	return t == 'function' || (!!(t == 'object' && object[property])) || t == 'unknown'//IE中xhr.open返回unknown
}
浏览器检测？

2.2怪癖检测
如IE8[[DontEnum]]的属性？

2.3用户代理检测
利用代理检测客户端精确信息和版本


3 DOM
3.1节点层次
3.1.1①Node类型
每个节点都有一个nodeType属性，其值是12个数值常量之一，如Node.ELEMENT_NODE//1
兼容性：IE没有公开Node类型的构造函数，因而不能直接使用常量来对比判断，而应该直接使用常量对应的数值

除了nodeType外，节点还有nodeName和nodeValue两个常用属性，还有childNodes属性，childNodes是一个类似数组的结构，但不是Array实例，且是基于DOM结构动态执行查询的结果，因而是可以动态刷新的。有length属性，且可以使用xxx.childNodes[index]或xxx.childNodes.item(index)来访问。

在IE8以后的版本（9+），可以将NodeList转换为数组，IE8及以前版本是将NodeList实现为COM对象。
function convertToArray(nodes) {
	var array = null
	try{
		array = Array.prototype.slice.call(nodes, 0)//非IE
	} catch(ex) {
		array = new Array()
		for (var i=0,len = nodes.length;i<len;i++) {
			array.push(nodes[i])
		}
	}
	return array
}

②节点关系（父子兄弟）
此外，每个节点也都有parentNode属性，而兄弟节点之间可以通过nextSibling和previousSibling访问，第一个节点的pre...为null，最后一个节点的next...为null。父节点的firstChild和lastChild分别执行子节点的第一个和最后一个节点。检测有无子节点，除了判断childNodes是否为空为null、判断长度外，可以之间使用hasChildNodes()方法。还有ownerDocument属性，执行表示整个文档的节点（当前dom的最外层）

③节点操作
appendChild()，向目标节点的childNodes的末尾插入节点，返回新增的节点。一个节点不能同时出现在两个地方，因而如果参数节点是已经存在的，则会从原位置移动到目标位置。一个小技巧，有多个子节点时，可以通过appendChild将目标子节点调整成lastChild。

insertBefore()，如果不放在末尾，可以使用该方法。与前边的方法类似，返回新节点，但是参数有要插入的节点和参照节点两个，执行后插入的节点成为参照节点的前一个兄弟节点（previousSibling）。如果第二个参数为null，则等效于appendChild()

replaceChild()参数是要插入替换的节点和被替换移除掉的节点，返回被移除的节点。

removeChild()参数是要移除的节点，返回该节点。

并不是全部类型的节点都有子节点。

④其他
cloneNode()，参数是一个布尔值，表示是否深复制（深复制会复制其整改子节点数，浅复制只复制本身节点（子节点为null））。不会复制事件，但IE有会复制事件的bug，最好在复制之前移除事件。

normalize(),处理文本节点，将空的文本节点移除，将相邻的文本节点合并。
以上两个方法所有类型的节点都支持。

3.1.2Document类型
①文档子节点
JS通过document类型表示文档，js里document对象是HTMLDocument的一个实例，继承自Document类型，表示整个HTML页面，且是window对象的一个属性。
节点类型nodeType是9，像一个普通节点一样拥有nodeName等其他属性。
其子节点可以是DocumentType、Element、ProcessingInstructior、Comment。但还可以通过childNodes来访问文档元素，或通过documentElement属性访问（一般使用这个，指向<html>元素）。可以直接用过body属性来访问body标签，同理还有head等。
document.doctype//对<!DOCTYPE>的引用。不同浏览器对该属性的支持差别很大。类似的对注释的处理也差异很大。

②文档信息
一些特殊属性：title（指向<title>节点），URL，domain（域名），referrer（链接到当前页面的那个页面的URL）。其中domain和title是可以设置的。但安全限制不允许修改domain，因而只能设置为url中包含的域名（可以子域名二级域名），可以通过这样修改来解决跨域问题，但修改是不可逆的。如：
document.domain = b.com//原url：a.b.com。但设置了之后想再设置回去，则会抛出异常。即可以由紧致设置为松散，但不能由松散设置为紧致（始于IE8）。

③查找元素
getElement(s)Byxxxxxx（id，name，tagName等），如果是HTMLCollection对象的结果（类似数组），则有namedItem()方法，参数是name，且可以直接通过name来访问，如var el = document.getElementsByTagName('img')['myImg']//等效于xxxx(前边的内容)('img').namedItem('myImg')。
如果tagname参数是"*"，则返回页面中的所有元素。

④特殊元素
document.anchors（所有带name属性的<a>）
	.applets（所有applet元素）
	.forms....
	.images...
	.links（所有带href特性的<a>）

⑤DOM一致性检测
document.implementation
有hasFeature()方法，参数是功能名称和版本号，可配合前边的兼容性检测一起使用

⑥文档写入
write(),writeln()（会换行）,open(),close()
如document.write('<script>xxxxx' + '<\/script>')// 注意\/
如果在页面加载过程中write，会直接向页面输入，如果在页面加载完后write，则会重写整个页面。（严格模式不支持文档写入）open和close用于打开和关闭页面的输出流。

3.1.3Element 类型
nodeType为1，nodeName为元素标签名（不同浏览器的大小写可能不同）。
①HTML元素
特性：id，title，lang（语言），dir（方向，值为ltr（left-to-right）或rtl）,className

②取得特性
getAttribute()（一般直接获取特性，获取自定义特性时才用）,setAttribute(),removeAttribute()。
自定义特性，即不在标准特性中的特性，H5规范要求自定义特性前边加上data-，特性名称不区分大小写。以上方法对自定义特性也有效。

③attributes属性
与NodeList类型，attributes属性中包含一个NamedNodeMap。包含的方法：
getNamedItem(name),removeNamedItem(name),setNamedItem(node(添加节点)),item(pos下标)。
每个特性节点有specified属性，表示是否是指定的或已通过setAttribute添加的。

④创建元素
使用document.createElement(标签名HTML中不区分大小写)，参数也可以是完整的元素的字符串，但是这样会有一些局限性。

3.1.4Text类型（nodeType 3,nodeName '#text',nodeValue或data都是节点包含的文本,不支持子节点，有length）
appendData()将文本内容添加到节点末尾，
deleteData(起点下标，要删除的长度)，
insertData（位置下标，要插入的内容），
replaceData（起点位置下标，要替换的长度，被替换成的文本）
splitText(要分割的下标位置)
substringData(起点下标，长度)

修改节点内容时，到呈现到页面上会被根据文档类型编码

<div></div>//没有文本节点
<div> </div>//直接是一个空格就相当于是一个文本节点

创建文本节点：createTextNode()
规范化文本节点：normalize()（在父节点上执行）
分割。。。：splitText()

3.1.5 Comment类型（nodeType 8,nodeName '#comment'，nodeValue或data是注释内容，没有子节点）
与Text类型继承自相同的基类，拥有和Text类型除splitText()方法外的全部方法
createComment()

3.1.6 CDATASection类型（基于XML，与comment类似）

3.1.7 DocumentType类型（支持性有限）

3.1.8 DocumentFragement类型（文档片段，一般用于循环插入页面时作为中转避免多次渲染，有create方法）

3.1.9 Attr类型（name-名称，value-值，specified-默认或指定的）
var attr = document.createAttribute('align')
attr.value = 'left'
element.setAttributeNode(attr)
alert(element.attributes['align'].value)//left
alert(element.getAttributeNode('align').value)//left
alert(element.getAttribute('align'))//left

3.2 DOM操作
3.2.1动态脚本，动态样式
在需要时加载js，即在js里向页面appendChild指定js或js片段。不会立即下载？？（不会影响前边的？但是加载后后边可以直接使用）
function loadScript(url) {
	var script = document.createElement('script')
	script.type = 'text/javascript'
	script.src = url
	document.body.appendChild(script)
}
// 判断是否加载完成？

function loadScriptString(code) {
	var script = document.createElement('script')
	script.type = 'text/javascript'
	try {
		script.appendChild(document.createTextNode(code))
	} catch (ex) {
		script.text = code//兼容IE
	}
	document.body.appendChild(script)
}

function loadStyles(url) {
	var link = document.createElement('link')
	link.rel = 'stylesheet'
	link.type = 'text/css'
	link.href = url
	document.getElementsByTagName('head')[0].appendChild(link)
}
// css是异步加载的，不需要关系什么时候加载完成的问题
function loadStyleString(css) {
	var style = document.createElement('style')
	style.type = 'text/css'
	try {
		style.appendChild(document.createTextNode(css))
	} catch (ex) {
		style.styleSheet.cssText = css// 兼容IE。另外，ie中重复设置一个style的属性或设置为空时容易崩溃
	}
	document.getElementsByTagName('head')[0].appendChild(style)
}

3.2.2 表格
<table>属性和方法：
caption：对<caption>元素的指针
tBodies：<tbody>元素的HTMLCollection
tFoot：对<tfoot>元素的指针
tHead：同上
rows：所有行的HTMLCollection
createTHead()/createTFoot()/createCaption()/insertRow(下标)
deleteTHead()/deleteTFoot()/deleteCaption()/deleteRow(下标)
<tr>元素属性方法：
cells：<tr>元素中单元格的HTMLCollection
deleteCell(index)/insertCell(index)

3.2.3 使用NodeList
NodeList，NamedNodeMap，HTMLCollection：
都是动态的。应尽量减少访问次数，因为每次访问NodeList，都会运行一次基于文档的查询，所以可以将从NodeList中取的的值缓存起来使用来避免多次查询。

4 DOM扩展
4.1 选择符API
如jQuery中的选择器等。Selectors API（W#C发起制定的一个标准） Level 1的核心方法：
querySelector()和querySelectorAll()（与前者差异：返回的是一个NodeList实例而不是具体的元素）
同样，访问这个NodeList集中的某一项的时候可以使用.item(i)或[i]

matchedSelector(),避免兼容性问题（ie里是msMatchedSelector(),谷歌是webkitMat...,火狐是mozM...）
使用：if (document.body.matchesSelector('body .page1'))
// 兼容性封装
function matchesSelector(ele, selector) {
	if (ele.matchesSelector) {
		return ele.matchesSelector(selector)
	} else if (ele.msMatchesSelector) {
		return ele.msMatchesSelector(selector)
	} else if (ele.mozMatchesSelector) {
		return ele.mozMatchesSelector(selector)
	} else if (ele.webkitMatchesSelector) {
		return ele.webkitMatchesSelector(selector)
	} else {
		throw new Error('xxx')
	}
}
使用：if(matchesSelector(document.body, 'body .page1'))

4.2 元素遍历
为避免不同版本对空格是否返回文本节点的兼容性问题，w3c定义了一组新的属性：
childElementCount：不包括文本和注释的子元素个数
firstElementChild：指向第一个元素，firstChild的元素版
lastElementChild：.../previousElementSibling:.../nextElementSibling:...

4.3 H5（这里只介绍DOM方面的扩展）
① 与类相关的扩充：
getElementsByClassName()（document或节点上都可以使用）；
classList属性（DOMTokenList的实例）：与前边的集合类型类似，可以使用item(i)或[i]访问内部元素，且有add(),contains(),remove(),toggle()方法，用以对class样式进行直接增删改和判断等，解决了改className时需要拆分合并的效率问题。

②焦点管理
document.activeElement，引用DOM中当前获得了焦点的元素（获得焦点的方式：页面加载，用户输入，focus()方法）
document.hasFocus()方法判断是否获得了焦点，以确认是否在与页面交互（如切换到别的页面时当前页面的视频播放停止）

③HTMLDocument的变化
readyState属性（loading、complete），兼容模式compatMode（CSS1Compat（标准模式），BackCompat（混杂模式）），head属性

④字符集属性
charset，默认是UTF-16，可以通过meta、响应头部或直接设置来修改
defaultCharset，默认字符集设置

⑤自定义数据属性
data-属性名
添加了自定义属性后，可以通过元素的dataset属性（DOMStringMap实例）来访问自定义属性的值

⑥插入标记
innerHTML属性，可以读取或修改内部内容。有一些元素不支持该属性
但在写入script的时候有一定的兼容性。script是无作用域的元素，可以通过添加时一起添加有作用域的空元素或设置defer属性来解决。如：
div.innerHTML = '_<style xxx>xxx</style>'
div.removeChild(div.firstChild)

outerHTML属性
与前者的差异在于outer是包括元素本身的节点数，而inner是元素的子节点

insertAdjacentHTML()方法
参数：插入位置和HTML文本
位置：‘beforebegin’作为前一个兄弟节点插入
‘afterbegin’作为第一个子元素插入
‘beforeend’作为最后一个子元素插入
‘afterend’作为后一个兄弟节点插入

内存和性能：
删除带事件处理的节点时，不会一并删除绑定的事件和js对象属性；
但是由于设置innerHTML和outerHTML属性时会创建浏览器级别的HTML解析器，效率会比js快很多；
但是要避免过多创建解析器，比如for循环中尽量不要新建。

⑦scrollIntoView()方法
参数如果是true或不传，则滚动后顶部对齐；如果传false，则尽可能出现在视口，如果可以呈现完，则底部对齐。


4.4专有扩展
①文档模式（meta）
②children属性
③contains()方法
DOM Level3的compareDocumentPosition()也能确认节点关系，返回结果根据节点关系有不同的结果
④插入文本
innerText，outerText。firefox不支持innerText，但支持textContent
⑤滚动
scrollIntoViewIfNeeded(alignCenter)，若在视口中则不处理，参数表示是否垂直居中；
scrollByLines(lineCount)将元素内容滚动指定行高
scrollByPages(pageCount)滚动指定的页面高度
后两者是元素自身，前两者是容器。


5 DOM2和DOM3
document.implementation
5.1 DOM变化

5.2 样式
5.2.1 访问元素的样式
css中样式属性是下划线，js里是style属性的对应驼峰属性

①DOM样式属性和方法
style对象的一些属性和方法：
cssText，length，parentRule（CSSRule对象）,getPropertyCSSValue(propertyName)，getPropertyPriority(propertyName)（如果设置了!important则返回important否则返回空）,getPropertyValue(propertyName)，item(index)（等同于[index]）,removeProperty(propertyName),setProperty(propertyName, value, priority)

getPropertyCSSValue()返回的是一个对象

② 计算的样式
DOM2级样式增强了document.defaultView，提供了getComputedStyle()方法，参数是元素和伪元素如‘:after’，第二个可以是null；而这个方法在IE中不支持，ie可以使用currentStyle属性代替。

5.2.2 操作样式表
CSSStyleSheet，继承自StyleSheet。继承的属性：
disabled，href，media（支持的媒体类型的集合），ownerNode（ie不支持），parentStyleSheet，title，type，（除了disabled，其他都是只读），cssRules（ie为rules），ownerRule，deleteRule(index)（ie是removeRule()）,insertRule(rule,index)（ie是addRule()）

document.styleSheets，item(index)或[index]来访问；
DOM的则是sheet属性，在ie中是styleSheet属性。如：
var link = document.getElementsByTagName('link')[0]
var sheet = link.sheet || link.styleSheet

①CSS规则
CSSRule对象表示样式表中的每一条规则，是一个供其他多种类型继承的基类，最常见的就是CSSStyleRule类型（其他有@import,@font-face等），CSSStyleRule属性如下：
cssText，parentRule，parentStyleSheet，type，selectorText，style（除了最后两个，剩下的IE都不支持）

关系示例：
var sheet = document.styleSheets[0]
var rules = sheet.cssRules || sheet.rules
var rule = rules[0]
alert(rule.selectorText)//如div.box
console.log(rule.style)// 如width，height

②创建规则
insertRule(样式文本，插入位置下标)，ie中是addRule，不过参数不同，将样式文本分成了前两个参数
如：
sheet.insertRule('body{height:100px}',0)
sheet.addRule('body','height:100px',0)//ie

function insertRule(sheet, selectorText, cssText, position) {
	if(sheet.insertRule){
		sheet.insertRule(selectorText+'{'+cssText+'}',position)
	} else if (sheet.addRule) {
		sheet.addRule(selectorText, cssText, position)
	}
}

③删除样式
deleteRule(),ie是removeRule()

5.2.3元素大小
①偏移量
offsetHeight，offsetWidth，offsetLeft，offsetTop。offsetParent是父元素的偏移量，通过循环累积，可以取得元素相对浏览器的偏移量。只读

②客户区大小
clientWidth，clientHeight。内容加上边距。不同模式（混杂模式等）的body的客户区大小获取方法有所不同。只读

③滚动大小
scrollHeight/Width/Left/Top，document的在document.documentElement上。与客户区的关系不同浏览器有所不同。文档的总高度是滚动大小和客户区大小的最大值。

④确定元素大小。
getBoundingClientRect(),返回的是一个矩形对象，包含left，top，right，bottom。IE8及更早的版本是以（2,2）为原点的。可封装为兼容的方法。

5.3遍历
两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator，TreeWalker，基于给定起点对DOM进行深度优先的遍历。IE不支持DOM遍历。
NodeInterator，使用document.createNodeInterator()创建实例，参数：
root，作为起点的节点
whatToShow，表示要访问哪些节点的数字代码（可选值以常量的形式在NodeFilter类型中定义，可使用按位或'|'来组合多个选项）
filter，一个NodeFilter对象，或一个表示应该接受还是拒绝某种特定节点的函数
entityReferenceExpansion，表示是否要扩展实体引用的布尔值，在HTML页面中没有用，因为其中的实体不能扩展。
var filter = {
	// 必须要有一个acceptNode,或者filter也可以直接是这一个方法
	acceptNode: function(node){
		return node.tagName.toLowerCase() == 'p'?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP
	}
}
遍历得到的结果又nextNode()和previousNode()两个方法。

TreeWalker
是NodeInterator的一个更高级版本，除包含nextNode和previousNode两个外还有更多的方法：
parentNode(),firstChild(),lastChild(),nextSibling(),previousSibling()，currentNode属性（读写，修改可实现修改起点）
创建方法是document.createTreeWalker(),参数与前者相同。
在filter上稍有不同，区别在于不满足时的处理，且有FILTER_REJECT常量。

5.4 范围
5.4.1 DOM中的范围
document.createRange()方法
属性方法：
startContainer：包含范围起点的节点（选区中第一个节点的父节点）
startOffset：startContainer中起点的偏移量
endContainer：。。。（选区中最后一个节点的父节点）
endOffset：。。。
commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树中位置最深的那个

①用DOM范围来实现简单选择
选择文档中的一部分最简单是selectNode()或selectNodeContents(),参数是一个DOM节点。两者区别是后者只选取子节点，前者选取包括节点本身
如：
var range = document.createRange()
range.selectNode(document.getElementById('xxx'))
精细选取：
setStart/EndBefore/After(refNode)4个方法

②用DOM范围实现复杂选择
使用setStart()和setEnd()，参数是一个参照节点和一个偏移量。如此其范围的属性会相应的被修改为设置的参数。

③操作DOM范围中的内容。
如，range.deleteContends(),extractContents()。两个方法都会移除选取范围里的元素，差别在于后者返回被移除的片段，可以使用该返回值来达到插入别的地方的功能（就像剪切粘贴）。
此外还有cloneContents()方法

④插入DOM范围中的内容
insertNode()，向范围选区的开始处插入一个节点

⑤折叠DOM范围
collapse(),参数true表示折叠到起点，false表示到终点

⑥比较DOM范围
compareBoundaryPoints()，比较是否公共边界（起点终点）,参数是两个，一个是起点终点（Range.START/END_TO_END/START），一个是用来比较的范围2。结果：相同返回0，在前返回-1，在后返回1

⑦复制DOM范围
cloneRange()

⑧清理DOM范围
使用完后调用detach()来清理以达到内存回收。

在IE8之前范围有所不同，功能点基本一致，主要是对应的方法属性名字不同，如果要兼容需要特殊关照处理。


6 事件

6.1事件流
6.1.1 事件冒泡（由内到外）
6.1.2 事件捕获（由外到内）
6.1.3 DOM事件流
事件捕获阶段，处于目标阶段，事件冒泡阶段。

6.2 事件处理程序
①HTML事件处理程序（onclick等）
（事件中this指向事件对象）
<input type='text' name="username"><input type='button' onclick='alert(username.value)'>

②DOM0级事件处理程序
document.getElementById('xxx').onclick=function(){xxx}
（事件中this指向当前元素）
置为null表示删除

③DOM2级事件处理程序
addEventListener(),removeEventListener()，参数：要处理的事件名，作为事件处理的函数，布尔值（true表示在捕获阶段调用事件处理程序，false表示在冒泡阶段调用事件处理程序）
document.getElementById('xxx').addEventListener('click',function(){},false),可以绑定多个事件，会按顺序执行。即该方式可以给一个元素绑定两个click事件且都会执行。
移除方法的参数与添加的方法相同，移除时必须指定事件名，比如，上边通过匿名函数添加的事件，则无法移除。

④IE事件处理程序
attachEvent()和detachEvent(),功能和参数与③中的前两个相同，但稍有不同，比如，3中是click，这里则需要onclick。this指向window，且添加多个同动作的事件时，指向顺序与3相反，后定义的先执行。

⑤跨浏览器的事件处理程序
var EventUtil = {
	addHandler: function(ele, type, handler) {
		if (ele.addEventListener) {
			ele.addEventListener(type, handler, false)
		} else if (ele.attachEvent) {
			element.attachEvent('on'+type, handler)
		} else {
			element['on'+type] = handler
		}
	},
	removeHandler: function(ele, type, handler) {
		if (ele.removeEventListener) {
			ele.removeEventListener(type, handler, false)
		} else if (ele.detachEvent) {
			element.detachEvent('on'+type, handler)
		} else {
			element['on'+type] = null
		}
	}
}

6.3 事件对象event
属性（一些基本属性都是只读的）：
bubbles：事件是否冒泡
cancelable：是否可以取消事件的默认行为
currentTarget
defaultPrevented：true表示已经调用了preventDefault()（DOM3级事件中新增）
detail
eventPhase：即前边说的3个阶段，分别用1,2,3表示
preventDefault()：取消事件的默认行为，cancelable 为true可以使用
stopImmediatePropagation()：取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用
stopPropagation()：取消事件的进一步捕获或冒泡，bubbles为true可以使用
target
trusted：true表示浏览器生成，false表示js创建
type，view（等同于发生事件的window）
在事件处理程序内部this指向currentTarget，而target是实际目标。

IE上：event是window的属性，尤其是在DOM0及，只能通过window.event获取
属性和方法：
cancelBubble：默认false，设置为true就可以取消冒泡
returnValue：默认为true，设置为false就可以取消默认行为
srcElement：等同于前边的target
type

跨浏览器的事件对象：
在前边EventUtil的基础上，新增：
getEvent: function(event) {
	return event ? event : window.event
},
	// 下边三个event入参是上边getEvent获取到的event
getTarget: function(event) {
	return event.target || event.srcElement
},
preventDefault: function(event) {
	if (event.preventDefault) {
		event.preventDefault()
	} else {
		event.returnValue = false
	}
},
stopPropagation: function(event) {
	if (event.stopPropagation) {
		event.stopPrppagation()
	} else {
		event.cancelBubble = true
	}
}

6.4 事件类型
UI事件，焦点事件，鼠标事件，滚动事件，文本事件，键盘事件，合成事件（输入法编辑器输入字符时触发），变动事件（底层DOM结构变化时触发），变动名称事件（元素或属性名变动时触发，已废弃）
以上是常规事件

①UI事件：
DomActivate（废弃），load，unload（多用于清除引用，以避免内存泄露），abort（中途停止），error，select（文本），resize，scroll

②焦点事件：
bulr，DOMFocusIn（废弃，改为focusin），DOMFocusOut（废弃，改为focusout），
focus，focusin，focusout

③鼠标，滚轮
click，dbclick，mousedown，mouseenter，mouseleave，mousemove，mouseout，mouseup（顺序：
mousedown-》mouseuo-》click-》mousedown-》mouseup-》click-》dbclick），mousewheel（滚轮）

event对象的clientX/Y,pageX/Y（无滚动时两种相同），两者的差就是页面的scrollLeft和Top，screenX/Y（相对于屏幕的位置）

修改键：即shift，ctrl，alt，meta等组合键，对应的在event对象中有shiftKey,ctrlKey,altKey,metaKey表示是否按下相应的键。

相关元素：对于mouseover，mouseout等这种涉及到两个对象切换的事件，event对象有relatedTarget表示相关元素。（从相关元素移入和移出到相关元素）IE8以前有一些兼容性问题：
getRelatedTarget: function(event) {
		if (event.relatedTarget) {
			return event.relatedTarget
		} else if (event.toElement) {
			return event.toElement
		} else if (event.fromElement) {
			return event.fromElement
		} else {
			return null
		}
	}

区分按下的是哪个键：
event的dom的button属性，0,1,2
getButton: function(event) {
		if (document.implementation.hasFeature('MouseEvents', '2.0')) {
			return event.button
		} else {
			switch (event.button) {
				case 0:
				case 1:
				case 3:
				case 5:
				case 7:
					return 0
				case 2:
				case 6:
					return 2
				case 4:
					return 1
			}
		}
	}

滚轮滚动：（firefox是DOMMouseScroll）
getWheelDelta: function(event) {
		if (event.wheelDelta) {
			return (client.engine.opera && client.engine.opera < 9.5 ? -event.wheelDelta : event.wheelDelta)
		} else {
			return -event.detail * 40
		}
	}

触摸设备（移动端）：无双击，等差别
屏幕阅读器（无障碍性问题）：不使用 mousedown，mouseover，dbclick

④ 键盘与文本事件：
keydown，keypress，（以上两个按住不放会重复触发）keyup，textInput。
也有shift、ctrlKey等，ie没有metaKey

键码keyCode

字符编码
charCode
data

char，key，location，getModifierState()，inputMethod（输入、复制、拖放等），只有IE9+支持

⑤复合事件（IME输入法编辑器，DOM3）
compositionstart,compositionupdate,compositionend

⑥变动事件（MutationEvents，DOM2）
DOMSubtreeModified，DOMNodeInserted，DOMNodeRemoved，DOMNodeInsertedIntoDocument，DOMNodeRemovedFromDocument，DOMAttrModified，DOMCharacterDataModified

⑦H5事件
一些比较完善支持的事件:
contextmenu,beforeunload（event.returnValue = 'xxx';return 'xxx'）,DOMContentLoaded,readystatechange,pageshow,pagehide,hashchange（window对象的）

⑧设备事件
orientationchange:（ios设备，window的）
window.orientation表示屏幕的方向，分别有0,90，-90

MozOrientation:(firefox,window的，带加速计设备才支持)
event有x,y,z 3个属性表示当前的屏幕方向，值在-1~1

deviceorientation（与前者类似，支持较广泛）
有额外属性：alpha（左右度数），beta（前后度数），gamma（旋转度数），absolute，compassCalibrated（指南针是否校准过）

devicemotion（）
属性：acceleration（包含x,y,z属性，不考虑重力情况下每个方向上的加速度），
accelerationIncludingGravity（同上，考虑z轴自然重力加速度），
interval（时间，必须在另一个devicemotion事件触发前传入），
rotationRate（alpha，beta，gmma）
使用前需判断是否为null

⑨触摸和手势
touchstart，touchmove（手指在屏幕滑动时连续触发，调用preventDefault()可阻止滚动），touchend，touchcancel。
以上几个事件都会冒泡也都可以取消。以上事件对象除常见dom属性外，还有以下属性：
touches，targetTouches，changeTouches，clientX，clientY，identifier，pageX，pageY，screeenX，screenY，target

手势事件：
gesturestart：（两个手指都按下时）
gesturechange：
gestureend：（任一手指移开时）

6.5内存和性能
每个函数都是对象，都会占用内存，进而影响性能。
6.5.1事件委托
因为这些事件大部分都是冒泡的，即在dom树中尽量最高的层次添加一个事件处理程序，而不是给每个需要处理点击的元素都加，然后在事件程序中根据点击target来执行不同的操作。比较适用的是click，mousedown/up,keydown/up,keypress。

6.5.2移除事件处理程序
在不需要的时候移除事件处理程序
如元素被删除了，此时对应的事件处理程序如果不需要了可以移除。如果移除的是包含绑定该事件的元素，则要在事件中提前移除。（在事件中删除绑定事件的元素也是阻止冒泡的一种方式）
另外，在页面卸载（切换，刷新等）时，最好在onunload事件中将事件处理移除，此时如果使用事件委托则移除比较方便。（使用onunload事件处理程序意味着页面不会被缓存在bfcache中）

6.6模拟事件
6.6.1DOM中的事件模拟
document.createEvent()参数是一个字符串表示事件类型，DOM2级使用英文复数形式（结尾带s），DOM3级使用单数。常用如下：
UIEvent（s），MouseEvent（s）,MutationEvent（s），HTMLEvents（DOM3没有该类型）

上边创建了事件后，使用dispatchEvent()触发（可以在任意dom元素触发），而触发后的执行，则是在创建了事件之后需要通过如鼠标事件是创建事件后返回的对象的initMouseEvent()来指定的，参数有15个，对应event的属性。

模拟键盘：类型是KeyboardEvent
初始化方法是initKeyEvent()
类似有模拟鼠标、键盘、按键等

自定义DOM事件：
createEvent('CustomEvent'),initCustomEvent()（参数有type（如keydown），bubbles，cancelable，detail）
如：EentUtil,addHandler(div, 'myevent', function(event){
	alert(event.detail)//就是下边指定的'hello'
})//指定myevent
if (document.implementation.hasFeature('CustomEvents','3.0'){
	event = document.createEvent('CustomEvent')
	event.initCustomEvent('myevent',true,false,'hello')

IE8之前，document.createEventObject()来创建event对象，没有参数，然后再为返回的对象指定属性，即没有前边说的initxxx，而是直接给其对应的属性赋值。触发则是fireEvent()，而事件的类型，则是作为fireEvent的第一个参数指定，第二个参数是事件
	event.dispatchEvent(event)
}


7 表单
7.1
常用属性方法：action，method，name，reset(),submit()
可通过id或document.forms[name/index]等获取
提交：input type='submit',button type='submit',input type='image' src='xxx'

可以使用上边添加submit事件的方法取消阻止默认行为来阻止提交，而直接调用submit()方法不会触发添加的事件。重置表单type=‘reset’，同样可以添加重置事件，但是调用reset会触发事件。

表单的元素是elements属性，可以通过name或者index访问，有length，name相同则返回NodeList。
除了<fieldset>元素，所有表单字段都拥有相同的一组属性：
disabled,form（只读）,name,readOnly,tabIndex（tab切换的序号）,type（select-one/multiple/button/submit等等）,value,autofocus。方法：focus(),blur();
事件：blur,change,focus，（文本有select）

7.2文本框脚本
input：
type=‘text’，size（显示的字符数），maxlength；
textarea：
rows，cols，无最大字符数属性

两者的值都保存在value中。最好直接通过属性访问，而不是使用DOM的setAttribute等方法来读写这些属性。

select()方法，用于选中文本，常用于在focus事件中，效果就是获得焦点时直接选中，避免需要一个个删除。

而select后会触发select事件。
获取选择的文本
function getSelectedText(textbox) {
	if (typeof textbox.selectionStart == 'number') {
		return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd)
	} else if (document.selection) {
		// IE8及以前
		return document.selection.createRange().text
	}
}

选择文本：
除select()外，还有setSelectionRange(start,end),ie8及以前则是createTextRange(),然后collapse(),再moveStart(),moveEnd(),然后range.select()
function selectText(textbox, start, end) {
	if (textbox.setSelectionRange) {
		textbox.setSelectionRange(start, end)
	} else if (textbox.createTextRange) {
		var range = textbox.createTextRange()
		range.collapse(true)
		range.moveStart('character', start)
		range.moveEnd('character', end - start)
		range.select()
	}
	textbox.focus()
}

过滤输入：
在keypress事件中，输入不符合要求的字符时，通过preventDefault()来阻止。
前边的EventUtil.getCharCode()获取字符编码后，通过String.fromCharCode(charcode)可以获得对应的字符串。后边的逻辑看具体业务需求和浏览器而定。

操作剪贴板：
beforecopy，copy，beforecut，cut，beforepaste，paste。
访问剪贴板：IE的在window下的clipboardData，而其他则是在相关事件的event下。clipboardData有：
getData()（一个参数，表示数据类型，text，url等）,setData()（类型和要放的文本）,clearData()

getClipbordData: function(event, type='text') {
		var clipbordData = event.clipbordData || window.clipbordData
		return clipbordData.getData(type)
	},
	setClipbordData: function(event, value) {
		if (event.clipbordData) {
			// 返回的值是成功失败的布尔值
			return event.clipbordData.setData('text/plain', value)
		} else if (window.clipbordData) {
			return window.clipbordData.setData('text', value)
		}
	}
可在paste事件中用于粘贴前的判断校验。不过浏览器支持性有不同

自动切换焦点：
添加keyup事件，判断如果输入的长度等于maxlength则下一个元素focus()

H5约束验证api
required，type（email，url等，number，range，datetime，datetime-local，date，month，week，time等），min，max，step（stepUp/Down(steps（默认不传为1）)），pattern（正则）（检测是否支持：'pattern' in document.createElement('input')）

检测有效性：checkValidity(),form和单项都有该方法。
此外validity属性里有详细的校验信息：
customError：如果设置了setCustomValidity()则为true
patternMismatch：如果值与给定的pattern属性不匹配，返回true
rangeOverflow，rangeUnderflow（min和max校验）
stepMisMatch，tooLong，typeMismatch，valid，valueMissing（required校验）

禁用验证：form表单novalidate属性或在js里设置表单的noValidate=true
选项里比如提交按钮禁用验证则是formnovalidate属性

7.3 选择框脚本
add(newOption, relOption)：在相关项relOption之前插入新的选项
multiple：多选
options，remove(index)，selectedIndex（没有选则为-1），
size：选择框中可见的行数
选择框的type是‘select-one/multiple’
若没有指定value，则取文本。
options选项集合元素的属性：index,label,selected,text,value
修改选择项的方法：设置selectedIndex，或者设置选项的selected

添加选项：
①使用dom，创建option标签，插入文本节点，设置value属性，然后将option标签插入到select里（appendChild，insertBefore等）
②使用Option构造函数：new Option（text，value），然后插入。但是ie8及以前会有问题
③使用add，新建标签（如2中），然后select.add(标签，undefined)第二个参数传undefined才可以插入到结尾。

移除选项：
removeChild(选项)，选择框的remove(选项下标)，将选项置为null。3种方法

移动和重排选项：
insertBefore，appendChild等

表单序列化：serialize()

7.4
富文本编辑
原理是使用iframe嵌入一个文档，嵌入的文档的designMode设置为on（比如在嵌入的页面的onload里设置。），另外一种就是不需要插入文档，直接给需要作为富文本的元素设置contenteditable属性（js则是对应的驼峰属性:true，false，inherit（继承父元素））

操作富文本：（先选中区域？）
document.execCommand()，3个参数，分别是要执行的命令（特定字符），一个布尔值（是否提供用户界面，设置成false，firefox不支持true），第三个是null或具体值。
如：frames['richedit'].document.execCommand('createlink', false, 'www.xxx.com')

其他：queryCommandEnabled(命令)检测是否可以对当前选中的文本执行该命令；
queryCommandState(命令)确定是否已将命令应用到文本，
queryCommandValue(命令)

富文本选区：
框架iframe的getSelection()方法，可以确定实际选择的文本。是window和document的属性，返回一个Selection对象，属性：
anchorNode：选区起点所在节点
anchorOffset：在到达起点之前跳过的anchorNode中的字符数量
focusNode：选区终点节点
focusOffset：focusNode中包含在选区内的字符数量
isCollasped：起点终点是否重合
rangeCount：选区包含的DOM范围的数量
方法：
addRange(range)：
collapse(node, offset):
collapseToEnd(),collapseToStart(),containsNode(node)（节点是否包含在选区）,
deleteFromDocument()（删除选择的内容，与前边通过命令删除效果相同）,
extend(node, offset)（扩展）,getRangeAt(index),removeAllRanges()（相当于取消选择）,
removeRange(range),selectAllChildren(node)（取消选择并选中指定节点的所有子节点）,toString()

range有htmlText和pasteHTML()属性和方法。我们在提交到服务器时，直接取富文本的innerHtml即可。


8 Canvas
设置样式和宽高，获取上下文（getContext('2d/3d')），然后进行绘制。目前3D支持尚不完善。
导出图片：toDataURL(MIME类型格式)

8.1 2D上下文
①填充和描边
对应的属性是fillStyle，strokeStyle。它们的默认值是‘#000000’，可以是字符串、渐变对象、模式对象。一旦设置后，后边绘制的对象就是设置的这两个样式，直到被再次设置成别的值。

②绘制矩形
矩形是唯一一种可以直接在2D上下文中绘制的形状。矩形相关方法：
fillRect(),strokeRect(),clearRect()，参数都是x，y，宽，高这4个。
分别是画填充的矩形，画只有边框的矩形，清除指定区域（扣除）

③绘制路径
beginPath(),然后开始绘制：
arc(x,y,radius,startAngle,endAngle,角度是逆时针还是顺时针（true为逆时针）)；
arcTo(x1,y1,x2,y3,radius)：从上一点开始。。。;
bezierCurveTo(c1x,c1y,c2x,c2y,x,y):从上一点，以c1，c2两个点为控制点画到x，y；
lineTo(x,y),moveTo(x,y),
rect(x,y,width,height)：绘制矩形路径

如果想连到起点（即将线条区域封闭），使用closePath()；如果路径已完成，要使用fillStyle填充，可使用fill();还可以使用stroke()来为路径描边（不描边不显示？）；还可使用clip()在路径上创建一个剪切区域。

判断点是否在路径上：context.isPointInPath(x,y)

线条样式属性
lineCap:        设置或返回线条的结束端点样式
butt         默认。向线条的每个末端添加平直的边缘。
round         向线条的每个末端添加圆形线帽。
square         向线条的每个末端添加正方形线帽。

lineJoin:        设置或返回两条线相交时，所创建的拐角类型
bevel         创建斜角。
round         创建圆角。
miter         默认。创建尖角。

lineWidth:        设置或返回当前的线条宽度
number         当前线条的宽度，以像素计

miterLimit:        设置或返回最大斜接长度
number         正数。规定最大斜接长度。

④绘制文本
fillText(),strokeText()。参数：字符串，x，y，最大像素宽度（可选）。
属性：
(content.)font,textAlign,textBaseLine.
辅助确定文本大小measureText(text)，返回对象目前只有width属性，根据当前字体大小确定文本的宽度。

⑤变换
rotate(角度)，scale(x比例，y比例)，translate（x,y）将坐标原点移动到x，y；
transform(m1_1,m1_2,m2_1,m2_2,dx,dy)：直接修改变换矩阵，方式是乘以如下矩阵：
m1_1  m1_2  dx
m2_1  m2_2  dy
0     0     1
setTransform(m1_1,m1_2,m2_1,m2_2,dx,dy)，重置为默认后再执行上边的。

save()方法，将当前设置的颜色等保存在一个栈中，这样后边再修改就不会影响前边画好的了（？）。
restore()回到之前保存状态。save只保存设置和变换，不保存内容。

⑥绘制图像
drawImage(image元素, x, y, width, height)宽高默认是原图尺寸
或
drawImage(image,源图起点x,源图起点y,源图要截取的宽度,源图要截取的高度,目标起点x,目标起点y,目标区域宽度,目标区域高度)实现将源图的一部分画出来。
源图除了可以是image外，还可以是canvas

⑦阴影
shadowColor,shadowOffsetX,shadowOffsetY,shadowBlur

⑧渐变
createLinearGradient(x1,y1,x2,y2),createRadialGradient(x1,y1,radius1,x2,y2,radius2)
例如：
var grad = context.createLinearGradient(x1,y1,x2,y2)
grad.addColorStop(0, xxx)
grad.addColorStop(1, xxx)

context.fillStyle = grad
xxxx

⑨模式
模式就是重复的图像，可以用来填充或描边图形。
createPattern(img/video/canvas元素, 重复方式（即css中的background-repeat）)

⑩图像数据
getImageData(x,y,width,height)，返回的是ImageData实例，有宽高和data属性，data是一个数组，保存每一像素的数据，单个像素的数据是红绿蓝和透明度组成的数组。
putImageData(imageData,x,y)
例：
图像转黑白：
function getBWImg(image) {
	var canvas = document.createElement('canvas')
	canvas.width = image.width
	canvas.height = image.height
	var context = canvas.getContext('2d')
	context.drawImage(image, 0, 0)
	var imageData = context.getImageData(0,0,image.width,image.height)
	var data = imageData.data
	var average
	for(var i=0,len = data.length;i<len;i+=4) {
		average = Math.floor((data[i]+data[i+1]+data[i+2])/3)
		data[i] = average
		data[i+1] = average
		data[i+2] = average
	}
	imageData.data = data
	context.putImageData(imageData,0,0)
	image.src = canvas.toDataURL('image/png')
	canvas.remove()
}

11.合成
透明度：globalAlpha，混合模式：globalCompositionOperation。（context的属性）

8.2 WebGL
3d的canvas
8.2.1类型化数组
new ArrayBuffer(字节数)（数组缓冲器）
创建的对象通过byteLength属性访问字节数

①视图
一般是DataView
var view = new DataView(buffer, 开始节点, 占用字节长度（可选）)
这样视图也就有了byteLength和byteOffset两个属性，以及buffer属性，即ArrayBuffer对象
获取和写入则有根据位数不同的getter和setter（8,16,32,64）

②类型化视图
都继承DataView，
Int8Array，Unit8Array等

8.2.2
WebGL上下文
canvas.getContext('experimental-webgl')
返回null表示不支持。
可以添加第二个参数，来设置支持选项。比如alpha，depth等

常量，方法命名，绘图，视口，坐标，错误，着色器，纹理，读取像素

目前支持和规范尚未统一，3D也比2D更为复杂


9 H5脚本编程

9.1 跨文档消息传递（XDM，现叫Web Messaging），即不同域的通信
核心是postMessage()方法，参数是消息内容和接收方域，第二个参数是'*'表示任意,如：
向某iframe发送消息：
iframe.postMessage(xxx,xxx)
接收到消息会触发message事件，异步的。接收事件对象有data、origin、source 3个主要属性。
如：
EventUtil.addHandler(window, 'message', function(event) {
	if (event.origin === 'xxx') {
		//处理event.data
		// 消息回复
		event.source.postMessage(xxx,xxx)
	}
})
传递的data一般是字符串，有的浏览器可以是对象等，但是保险起见还是都转成字符串传递。

9.2 原生拖放
dragstart，drag，dragend事件（对于拖动元素）

dragenter，dragover，dragleave，drop事件（对于放置元素）

元素默认是不能放置的，所以移动到上边会显示禁止图标，但是可以通过为放置目标添加dragenter，dragover事件来使其变成可放置。

event.dataTransfer对象，有getData(),setData()方法，参数是数据类型和数据，类型有text和URL两种，现已扩展到很多种。设置的对象只有在drop事件中读取。默认拖动时会自动设置这些数据，也可以自己手动设置。扩展类型名在IE10及以前的版本都不支持；
有dropEffect和effectAllowed属性：
dropEffect属性有none，move，copy，link 4个可能值，每个都会导致光标显示不同符号，是针对放置目标的，可以在dropenter事件中修改；
dropEffect只有搭配effectAllowed才有用，后者的值有uninitialized，none，copy，link，move，copyLink，copyMove，linkMove，all。而该值是在dragstart事件中设置的

draggable属性

浏览器兼容性稍有不同，统一的处理方式是设置为可拖动-》在拖动开始事件和拖入事件设置数据和鼠标样式-》放置对象的一些方法中设置相应的效果样式-》drop事件最终处理数据和页面。

H5规定的dataTransfer对象的额外方法属性：
addElement(元素)：不会影响页面元素外观，而影响响应回调的对象，目前浏览器尚未都实现；
clearData(格式)：消除以特定格式保存的数据（实现较好）；
setDragImage(元素,x,y)：指定一幅图，拖动时显示在光标下方，xy是光标在图像中的坐标；
types

9.3 媒体元素
音频视频，如果不支持，则显示标签中的文本。属性：
src，width，height，poster（加载期间显示的图片），controls（操作控件是否显示），
不同浏览器可能媒体格式支持不同，因而可以在标签内使用一个或多个source元素，来指定不同的src

其他属性：
autoplay，buffered（当前已下载缓存的时间范围），bufferedBytes（当前已下载缓存的字节范围），
bufferingRate（每秒平均接收到的位数），bufferingThrottled（是否缓冲节流），currentLoop（当前循环次数），currentSrc，currentTime（已播放秒数），defaultPlaybackRate（播放速度），duration，ended，loop，muted（静音），networkState，paused，playbackRate，played，readyState，seekable，seeking，src，start，totalBytes，videoHeight，videoWidth，volume（音量）

事件：
abort，canplay，canplaythrough，canshowcurrentframe，dataunavilable，durationchange，emptied，empty，ended，error，load，loadeddata，loadedmetadata，loadstart，pause，play，playing，progress，ratechange，seeked，seeking，stalled，timeupdate，volumechange，waiting

方法：
play(),pause()

检测编解码器的支持情况：
canPlayType()参数是前边说的类型，返回是空或也许

Audio类型：
与Image类似，但是不是必须要插入到文档，所以可以实现类似隐身播放，如：
var audio = new Audio('xxx.mp3')
EventUtil.addHandler(audio, 'canplaythrough', function(event){
	audio.play()
})

9.4 历史状态管理
hashchange，history.pushState(状态对象，新状态标题，URL（可选）)
processState(state),popstate,replaceState(),pushState()


10 错误处理

10.1 try-catch，error.message属性
后如果接finally{}，则无论前边发生了什么，都会执行。catch和finally有一个即可。
错误对象：xxx
throw，throw new Error(xxx)；throw 任意值或对象

错误事件error，参数是错误信息，url，行号。return false可阻止浏览器的默认错误报告。

常见错误类型：类型转换、数据类型、通信。
如判断一个参数，最好不要直接用if(xxx)，而要用if(typeof xxx xxx)

（非）致命错误：
错误发生了之后无法继续执行。比如，在for循环中调用方法，如果中间发生错误，可能无法继续执行后边的。可以改成使用try catch，这样就不会影响下一次调用。

错误记录：
如：function logError(level, msg) {
	var img = new Image()
	img.src = 'log.php?lv='encodeURIComponent(level) + '&msg=' + encodeURIComponent(msg)
}
使用Image对象来发生消息，避免跨域，避免不支持XMLHttpRequest等。


11 XML,XPath,XSLT，E4X（已废弃）


12 JSON
JSON的语法可以表示三种类型：简单值（数字，字符串等），对象，数组。
JSON与JS的最大区别在于，必须（字符串和对象的label等）使用双引号。

12.1 解析和序列化

早期：eval(),
JSON的两个方法：stringify()和parse()，序列化时会忽略无效的项（如值为undefined的属性会被跳过）

stringify()有3个参数，JSON对象，过滤器（数组或函数），是否保留缩进及缩进数（数字）的选项。
如，过滤器表示序列化后的字符仅保留过滤器中列出的属性。如果过滤器是一个函数，函数有两个参数，分别是key和value，可以进行自定义的处理。

toJSON()方法，如Date的toJSON方法，或自己封装对象的toJSON。

parse()方法除了字符串外还可以接收一个参数，表示还原函数。与stringify的过滤器函数形式相同。


13 Ajax和Comet

13.1 XMLHttpRequest
最早是在IE5的MSXML库的一个ActiveX对象实现。在IE7以后，可直接使用XMLHttpRequest对象。

方法：
open():参数：请求类型（get，post等），url，是否异步

open只是启动，不会发送请求，需要调用send()才会发送

send():参数：body数据，如果不需要，必须传null。
abort()取消

发送请求得到相应后，会自动填充XHR对象的属性，相关属性：
responseText，responseXML，status，statusText。
status 200表示成功，304表示可以使用缓存。

异步请求需要检测XHR对象的readyState属性，0表示尚未open，1表示open-》send中间，2表示send，3表示接收到部分，4表示完成。

对应的事件是readystatechange事件。需要在open之前指定onreadystatechange事件才能保证跨浏览器兼容。

HTTP头部信息：
setRequestHeader(key, value)（需要在open之后，send之前）
getResponseHeader(key),getAllResponseHeaders()

13.2 XMLHttpRequest 2级

①FormData
例如：
var data = new FormData()
data.append(key, value)

var data = new FormData(document.forms[0])

②超时设定
timeout，方法：ontimeout
超时时readystate是4，在readystatechange中可能会异常，因而可以包在try-catch里

③overrideMimeType(type)，需在send之前

13.3 进度事件
loadstart，progress，error，abort，load，loadend
需在open之前添加，progress有event参数

13.4 跨域，CORS
发送请求时添加额外的Origin头部，如果服务器认为可以接收这个请求，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源可以回发‘*’）

①IE的XDR（XDomainRequest）
只能设置头的Content-Type等，open方法只有两个参数，请求都是异步的。

②其他浏览器
webkit通过XHR实现了跨域的原生支持，只需要在跨域时open传的url用绝对URL即可。头部的一些读写稍有限制

③Preflighted Requests（支持性有限）

④带凭据的请求

⑤封装
function createCORSRequest(method, url) {
	var xhr = new XMLHttpRequest()
	if ('withCredentails' in xhr) {
		xhr.open(method, url, true)
	} else if (typeof XDomainRequest != 'undefined') {
		xhr = new XDomainRequest()
		xhr.open(method, url)
	} else {
		xhr = null
	}
}

13.5 其他跨域技术
利用DOM中能够执行跨域请求的功能，可以在不依赖XHR的情况下发送请求，而且不需要修改后台代码

①图像Ping
使用Image指定src等于接口来实现跨域，可以侦听load和error事件，单向的。比如跟踪用户点击，页面访问量统计等。
只能发送get请求，无法访问响应文本，单向通信。

②JSONP（JSON with padding）被包含在函数调用中的JSON
组成：回调函数，数据
如：function handelRes(res) {}
var script = document.createElement('script')
script.src = 'xxx?callback=handelRes'
document.body.insertBefore(script, document.body.firstChild)

可以双向，可以访问返回，但是因为是从其他域请求，安全性需要保证，且对于请求是否失败不容易判断。

③Comet
服务器控制时间（如有数据刷新时才）向浏览器发送数据，然后浏览器在statechange事件中在状态3和4时根据返回的信息做一些处理和回调，以及是否再次查询。
实现方式：长轮询，流

④服务器发送事件（SSE）
实现方式：长轮询，短轮询，HTTP流。需要使用EventSource对象，事件有open，message，error，close()方法等。响应的MIME类型为text/event-stream。可以添加一个id，下次自动重连时会发送回去。
如
var source = new EventSource(同域URL)
suorce.onmessage = function(event) {}

⑤Web Sockets
在一个单独的持久连接上提供全双工，双向通信。使用了自定义的协议，URL模式是ws://，加密的是wss://，与http和https不同。
优点是数据包小，节省带宽，适合移动端。缺点是一致性和安全性。
例：
var socket = new WebSocket('ws://xxxxx')
属性：WebSocket.OPENING(0),WebSocket.OPEN(1),WebSocket.CLOSING(2),WebSocket.CLOSE(3)
没有readystatechange事件，但是有别的，可以close()关闭

打开之后，可以通过send(data)发送数据,只能发送纯文本。
接收消息：onmessage
其他事件：open，error，close。
不支持DOM2级事件侦听器，因此必须使用DOM0级语法定义事件处理程序。
如socket.onopen = xxx,socket.onerror = xxx,socket.onclose = xxx
close事件的event才有信息，包含原因，状态等。

而XHR和SSE组合也能实现双向通信。WebSocket更适合聊天室等，且需要建立和维护WebSocket服务器。

13.6 安全性


14 高级技巧
14.1 高级函数

①安全的类型检测（Object.prototype.toString.call(xxx)）

②作用域安全的构造函数
function Person(name, age) {
	if (this instanceof Person) {
		this.name = name
		this.age = age
		this.job = job
	} else {
		return new Person(name, age)
	}
}
避免不加new关键字的时候被当做函数而非对象的构造函数，这样就会导致作用域this变成window，属性就被加到了window上。

另外，在继承时，也会出现作用域的安全问题。纵使被继承的构造函数做了作用域保护，但是继承者还是会有作用域问题，即使使用了new也是。此时需要继承原型。（call等继承方式需要巩固）

③惰性载入函数
比如，一个函数中需要进行多次if判断，比如XHR的兼容性判断，如果在每次请求时都进行创建，显然会降低性能。因而可以改成，在if判断里，将该方法重写，这样在下次执行时，就会直接执行最终被重写的方法，不用再每次都进行判断。与原来相比，在第一次执行时性能会稍微损失一点点，但在后续使用时性能会大大提升。
还可以将方法改成自执行的写法，在if分支返回不同的匿名函数，这样初始化时会损失一点性能。后续不再损失。

④函数绑定（同样是this和闭包的问题）

function bind(fn, context) {
	return function() {
		return fn.apply(context, arguments)
	}
}

⑤函数柯里化
基本方法同函数绑定


14.2防篡改对象
无法撤销，使用ES5新增的方法来设置，效果同改对象的几个设定相关属性。

①不可扩展对象
Object.preventExtension(obj)
判断是否可扩展：Object.isExtensible()//false

②密封对象
Object.seal()，不可扩展，不能删除属性和方法。判断是否密封Object.isSealed()//true

③冻结对象
Object.freeze()，不可扩展，密封，writable被设置为false，如果定义set函数则访问器属性可写。判断：Object.isFrozen()

14.3高级定时器
①重复的定时器
即将定时器interval改为timeout写法。事件机制是先入事件栈排好顺序然后执行完前边的（空闲了）再执行下一个，所以interval在出现在下一个时钟周期还未执行完前边的东西时会导致跳过。避免跳过，改成链式timeOut
setTimeout(function(){
	//xxxxx业务代码
	// if...
	setTimeout(arguments.callee, interval)
}, interval)

②Yielding Processes
比如在循环中运行需要比较久的模块，且循环次数多，导致超出了浏览器的限制，页面就会“崩溃”。可采用数组分块的方法，即将循环的数组拆开一项一项设置timeout执行
function chunk(arr, func, context) {// 数组，要执行的方法，上下文(可选)
	setTimeout(function(){
		var item = array.shift()
		process.call(context, item)
		if (array.length > 0) {
			setTimeout(arguments.callee, 100)
		}
	}, 100)
}
使用时如果需要保护数组不变，可以使用chunk(arr.concat(),xxx)，类似深复制的原理。

③函数节流
比如在操作DOM时，占用内存会比其他操作更多，如果占用过大，会导致页面崩溃，如IE使用resize
事件，在改变大小时是连续触发的。可使用定时器对函数进行节流。

函数节流的基本思想是，某些代码不可以在没有间隔的情况下连续重复执行。这里的原理就是在前边的基础上，判断旧的定时器是否执行完，没有则将其替换为新的定时器（之前的相当于被销毁不再执行）。
var processor = {
	id: null,//定时器id
	perfom: function(){},//实际要执行的代码
	process: function(){
		clearTimeout(this.id)
		var that = this
		this.id = setTimeout(function(){
			that.perfom()
		}, 100)
	}
}
processor.process()//调用
简化：
function throttle(method, context) {
	clearTimeout(method.id)
	method.tId = setTimeout(function(){
		method.call(context)
	},100)
}

14.4自定义事件
事件是js与浏览器交互的主要途径，事件是一种观察者设计模式，松耦合。对象可以发布事件。
观察者模式由两类对象组成：主体和观察者。
主体发布事件，观察者通过订阅这些事件来观察主体。主体不知道观察者，观察者知道主体的注册事件回调即事件处理程序。比如在DOM上，DOM元素就是主体，事件处理代码就是观察者。

而观察者不用于DOM时，就是自定义事件。
function EventTarget() {
	this.handlers = {}
}
EventTarget.prototype = {
	contructor: EventTarget,
	addHandler: function(type, handler) {
		if (typeof this.handlers[type] === 'undefined') {
			this.handlers[type] = []
		}
		this.handlers[type].push(handler)
	},
	// 触发
	fire: function(event) {
		if (!event.target) {
			event.target = this
		}
		if (this.handlers[event.type] instanceof Array) {
			var handlers = this.handlers[event.type]
			for (var i=0, len=handlers.length; i<len; i++) {
				handlers[i](event)
			}
		}
	},
	removeHandler: function(type, handler) {
		if (this.handlers[type] instanceof Array) {
			var handlers = this.handlers[type]
			for (var i=0, len=handlers.length; i<len; i++) {
				if (handlers[i] === handler) {
					break
				}
			}
			handlers.splice(i, 1)
		}
	}
}

14.5拖放
结合自定义事件的拖放
var DragDrop = function() {
	// 在自定义事件的基础上
	var dragdrop = new EventTarget(),
		dragging = null,
		diffx = 0,
		diffy = 0
	function handleEvent(event) {
		event = EventUtil.getEvent(event)
		var target = EventUtil.getTarget(event)
		switch (event.type) {
			case 'mousedown':
				if (target.className.indexOf('draggable') > -1) {
					dragging = target
					diffx = event.clientX - target.offsetLeft
					diffy = event.clientY - target.offsetTop
					dragdrop.fire({type: 'dragstart', target: dragging, x: event.clientX, y: event.clientY})
				}
				break
			case 'mousemove':
				if (dragging !== null) {
					// 指定位置
					dragging.style.left = (event.clientX - diffx) + 'px'
					dragging.style.top = (event.clientY - diffy) + 'px'
					// 触发自定义事件
					dragdrop.fire({type: 'drag', target: dragging, x: event.clientX, y: event.clientY})
				}
				break
			case 'mouseup':
				dragdrop.fire({type: 'dragend', target: dragging, x: event.clientX, y: event.clientY})
				dragging = null
				break
		}
	}
	// 公共接口
	dragdrop.enable = function() {
		EventUtil.addHandler(document, 'mousedown', handleEvent)
		EventUtil.addHandler(document, 'mousemove', handleEvent)
		EventUtil.addHandler(document, 'mouseup', handleEvent)
	}
	dragdrop.disable = function() {
		EventUtil.removeHandler(document, 'mousedown', handleEvent)
		EventUtil.removeHandler(document, 'mousemove', handleEvent)
		EventUtil.removeHandler(document, 'mouseup', handleEvent)
	}
	return dragdrop
}


15 离线应用与客户端存储
15.1 离线检测
navigator.onLine
事件：online，offline，在window对象上（IE不确定是否有）

15.2 应用缓存
从浏览器缓存中分出来的一块缓存区。要在其中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。示例：
CACHE MANIFEST
#Comment

file.js
file.css
有很多设置描述文件的选项和方法。
要将描述文件与页面关联，可以在<html>标签指定manifest属性为文件路径如：
<html manifest="xxx.manifest">，扩展名现在推荐使用.appcache。文件的MIME类型必须是text/cache-manifest。

离线存储的API，核心是applicationCache对象，有一个status属性，0-无，1-闲置，2-检查中，3-下载中，4-更新完成，5-废弃。事件：
checking，error，noupdate，downloading，progress，updateready，cached。
可手动调用update()方法触发事件，调用swapCache()来启用新应用缓存。
EventUtil.addHandler(applicationCache, 'updateready', function(){
	applicationCache.swapCache()
})

15.2 数据存储
① cookie
限制：
绑定在特定域名下，每个域名的cookie数量限制不同浏览器不同，大小限制4096B（4096+-1，因而最好设置不超过4095B），是每个域下的大小限制而不是单个cookie。

构成：
名称（不区分大小写），值（URL编码的），域（默认设置该cookie的域），路径（特定路径下才发送cookie），失效时间（设置时间后只有到时间才会删除，不再会关闭浏览器就删除），安全标志（指定后SSL连接才发，即https，设置方法是secure）
设置：
Set-Cookie:name=xxx; expires=xxx; domain=xxx; secure
分号+空格分割

JS中的cookie

子cookie，即在cookie的一段中再分段用以存储一些信息。

② IE用户数据（ie5）
元素save()保存和load()方法取，参数是指定的数据名称。。。

③ web存储机制
Web Storage，Storage对象
方法：
clear()（火狐没有）
getItem(name)
key(index)
removeItem(name)，或使用delete sessionStorage.属性名
setItem(name, value)
get set可换成使用点加属性名

sessionStorage:
浏览器关闭后消失；跨页面存在；崩溃后重启仍可用（IE不支持）；绑定于某个服务器会话，所以只能有存储的页面访问。
IE是异步写入，其他是同步。IE8有begin，commit来强制写入
有length属性，可用使用key(index)方法结合for循环来迭代，还可以使用for-in迭代

如果需要跨会话，则需要使用localStorage或globalStorage（被local取代）
localStorage：
同域名、端口、协议可访问；数据保留到JS删除或用户清除。其他同sessionStorage

storage事件
对Storage对象的任何操作都会触发storage事件，event属性：domain，key，newValue，oldValue。（支持性需注意一下）

限制：
对于每个来源来说的，限制一般是2.5M或5M

④ IndexedDB
替代Web SQL。异步操作,使用对象保存数据而非表。
var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB

使用：
  打开请求：indexDB.open(数据库名),返回IDBRequest对象。在对象上添加onerror和onsuccess，事件的event的target有errorCode或result（失败或成功时）

  指定版本号（默认没有版本号），setVersion(字符串),以区分是否打开过，建立对象存储空间

  对象存储空间：
示例：
var store = db.createObjectStore('users', {keyPath: 'username'}

  之后十一add()put()方法添加数据，参数是要保存的对象，分别用于新增和修改。可将其指定为一个变量，以方便为变量绑定error和success事件。如：
var request = store.add(xxx)
request.onerror = xxx

  事务：
db.transaction()创建事务，可指定参数来只加载指定的存储空间数据，如前边指定的‘users’，可使用数组来指定多个存储空间。第二个参数是访问模式，默认0表示只读，1读写，2改变，可用IDBTransaction接口的常量表示，在谷歌中叫webkitIDBTransaction。

  取的事务后可使用objectStore()传入存储空间名称来访问或操作，get(),delete(),clear(),add(),put()，操作同上。

  事务也有error和complete事件。

  使用游标查询：
在存储空间上调用openCursor()创建游标，同样需要绑定error和success事件。事件的target的result表示结果，保存IDBCursor实例或null，有以下属性：
direction，key，value，primaryKey
游标除了访问外还可以使用update()方法用指定对象更新当前游标的value，同样有error和success；
还可以使用delete()删除记录，事件同。
每个游标默认只发起一次请求，想要继续执行需要continue(key)或advance(项数)，没有则返回null。触发的是前边创建游标的事件（需确定）。

  键范围：IDBKeyRange对象
浏览器IE10+，谷歌叫webkitIDBKeyRange。指定范围方法：
only(key)
lowerBound(key, true（可选，表示不计该项）)
同理有upperBound
还有bound(上，下，两个同上的可选)

  指定了范围之后将其作为创建游标的参数即可。
  
  设定游标方向：IDBCursor，webkitIDBCursor，使用常量属性
可作为创建游标的第二个参数来指定方向

  索引
创建索引store.createIndex(索引名，索引属性名，{unique:true/false是否唯一})
然后就可以使用索引进行操作。。。。。。
deleteIndex删除索引

  并发问题
同源的另一个标签页也访问时。
指定onversionchange事件，在另一个标签调用setVersion时就会触发，处理的最佳方式是关闭数据库以保证版本顺利更新。然后可以指定onblocked事件，在关闭时触发，提醒用户关闭其他（相同）页面，然后再执行setVersion等。

  限制：同源，一般是5M大小，谷歌不允许本地文件访问。
